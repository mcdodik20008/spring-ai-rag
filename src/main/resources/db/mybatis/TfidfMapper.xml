<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
    "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="mcdodik.springai.scheduling.mapper.TfidfMapper">

    <!-- ===== ResultMaps ===== -->

    <!-- Узкая модель под дедуп -->
    <resultMap id="ChunkForDedupMap" type="mcdodik.springai.scheduling.model.ChunkForDedup">
        <id property="id" column="id"
            javaType="java.util.UUID"
            typeHandler="mcdodik.springai.db.mybatis.handler.UUIDTypeHandler"/>
        <result property="tfidf" column="tfidf" typeHandler="mcdodik.springai.db.mybatis.handler.JsonbMapDoubleHandler"/>
        <result property="tfidfNorm" column="tfidf_norm" jdbcType="DOUBLE"/>
    </resultMap>

    <!-- Узкая модель под TF-IDF расчёт -->
    <resultMap id="ChunkForTfidfMap" type="mcdodik.springai.scheduling.model.ChunkForTfidf">
        <id property="id" column="id"
            javaType="java.util.UUID"
            typeHandler="mcdodik.springai.db.mybatis.handler.UUIDTypeHandler"/>
        <result property="text" column="content" jdbcType="LONGVARCHAR"/>
        <result property="updatedAt" column="updated_at" javaType="java.time.Instant"/>
    </resultMap>

    <!-- ===== Selects/Updates ===== -->

    <!-- 00:00 — батчи на пересчёт TF-IDF -->
    <select id="selectChunksNeedingTfidf" resultMap="ChunkForTfidfMap">
        SELECT id, content, updated_at
        FROM rag_chunks
        WHERE (tfidf IS NULL OR tfidf_updated_at IS NULL OR updated_at > tfidf_updated_at)
        ORDER BY updated_at
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <update id="updateTfidf">
        UPDATE rag_chunks
        SET
        tfidf = #{u.tfidf, jdbcType=OTHER,
              typeHandler=mcdodik.springai.db.mybatis.handler.JsonbMapDoubleHandler},
        updated_at = NOW()
        WHERE id = #{u.id}
        AND tfidf IS DISTINCT FROM #{u.tfidf, jdbcType=OTHER,
              typeHandler=mcdodik.springai.db.mybatis.handler.JsonbMapDoubleHandler}
    </update>

    <!-- 03:00 — чтение только TF-IDF для дедупликации -->
    <select id="selectAllWithTfidf" resultMap="ChunkForDedupMap">
        SELECT rc.id, rc.tfidf, rc.tfidf_norm
        FROM rag_chunks rc
        LEFT JOIN rag_chunk_duplicates d ON d.dup_id = rc.id
        WHERE rc.tfidf IS NOT NULL AND rc.tfidf_norm IS NOT NULL
        AND d.dup_id IS NULL
        ORDER BY rc.id
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- кандидаты по пересечению ключей (top terms) -->
    <!-- безопасная сборка массива терминов через CTE -->
    <select id="findCandidatesByAnyTerms" resultMap="ChunkForDedupMap">
        <![CDATA[
        WITH terms(t) AS (
        VALUES
        <foreach collection="terms" item="t" separator=",">
            (#{t})
        </foreach>
        )
        SELECT id, tfidf, tfidf_norm
        FROM rag_chunks
        WHERE id <> #{id}
        AND tfidf ?| array(SELECT t FROM terms)
        LIMIT #{limit}
    ]]>
    </select>

    <!-- UPSERT дубликата -->
    <update id="upsertDuplicate">
        INSERT INTO rag_chunk_duplicates (dup_id, keep_id, sim_score)
        VALUES (#{dupId}, #{keepId}, #{sim})
        ON CONFLICT (dup_id)
        DO UPDATE SET
        keep_id = EXCLUDED.keep_id,
        sim_score = EXCLUDED.sim_score,
        created_at = NOW();
    </update>

</mapper>
